# ————————————————————————————————
#   Name: Zhiyuan Lu
#   ID: 1579058
#   CMPUT 274, Fall 2018
#
#   Weekly Exercise #2: Unfair Dice
# --------------------------------
import random


def biased_rolls(prob_list, s, n):
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the
               biased die, in the order they were generated.
    """

    random.seed(s)  # initialize the pseudo-random number generator
    prob_sum = 0  # contain the probability of each number on the dice in prob_list
    mapping = []  # a list which contains each number on m-sided die

    # computing the probability of the number on the dice when the dice is rolled.
    for prob in prob_list:
        prob_sum += prob
        mapping.append(prob_sum)

    mapping_number = []  # a list which contains the number on the dice is found

    # map all the probabilities in the range[0, 1) to the specific number on the sides of the dice
    # then generate n rolls of the die, each roll would generate an integer(1 <= integer <=m)
    # add these integers into mapping_number list
    # in order to find all values that the dice is rolled for n times.
    for j in range(n):
        random_rate = random.random()  # [0, 1)

        i = 0
        while i <= len(prob_list):
            if random_rate < mapping[i]:
                mapping_number.append(i + 1)
                break
            i += 1

    rolls = mapping_number
    # return the resulting rolls
    return rolls


def draw_histogram(m, rolls, width):
    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments:
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """
    # solve the problem here by replacing the pass keyword
    print("Frequency Histogram: %d-sided Die" % m)

    count_list = []  # a list which contains the times of each number on the dice appears

    # find each value on the dice appears x times
    # append these counted numbers into count_list
    for j in range(0, m + 1):
        count_num = rolls.count(j)
        count_list.append(count_num)
    # find the value which appears the most in count_list
    max_value_count = max(count_list)
    # iterate each number on the dice, print * if the value on the dice is found, as scaled
    for i in range(1, m + 1):
        num_count_star = round(count_list[i] * (width / max_value_count))
        num_count_dot = width - num_count_star
        print("%d:%s" % (i, num_count_star * "*" + num_count_dot * "."))

    # this function should print to standard output
    # you should not return anything!


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.

    rolls = biased_rolls([1/6, 1/6, 1/6, 1/6, 1/6, 1/6], 42, 20)
    print(rolls)
    draw_histogram(2, rolls, 50)
